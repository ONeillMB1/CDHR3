#!/usr/bin/env python

import argparse
import sys
from Bio import SeqIO
import os
import getopt
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt

#######################################################################
##This script collates major summary statistics from the genome_results  
##file generated by bamqc (Qualimap).
#######################################################################


class FullPaths(argparse.Action):
    """Expand user- and relative-paths"""
    def __call__(self, parser, namespace, values, option_string=None):
        setattr(namespace, self.dest,
            os.path.abspath(os.path.expanduser(values)))

def is_file(filename):
    """Checks if a file exists"""
    if not os.path.isfile(filename):
        msg = "{0} is not a file".format(filename)
        raise argparse.ArgumentTypeError(msg)
    else:
        return filename

def get_arguments(): 
    """Parse command line arguments"""
    parser = argparse.ArgumentParser(
        description="Collate summary info from multiple bamqc runs")
    parser.add_argument('-v', '--vcf',
        help = 'file containing paths to bamqc results that are to be collated', 
        type = is_file,
        required = True)
    parser.add_argument('-t', '--tpedDir',
        help = 'file containing paths to bamqc results that are to be collated', 
        #type = is_dir,
        required = True)
    parser.add_argument('-o', '--output',
        help = 'name of output file,',
        required = True)
    return parser.parse_args()

def find_ancestral():
    positions = []
    d = {}
    with open(args.vcf, 'r') as vcf:
        for line in vcf:
            if line[0] != "#":
                line = line.strip().split('\t')
                pos = int(line[1])
                positions.append(pos)
                REF = line[3].upper()
                ALT = line[4].upper()
                info = line[7].split(";")
                if len(REF) == 1 and len(ALT) == 1:
                    for i in info:
                        if i[0:2] == "AA":
                            aa = i.split("=")[-1].strip("|").upper()
                            if aa == ALT:
                                d[pos] = [ALT,REF]
                            else:
                                d[pos] = [REF,ALT]
    print("{0} positions in vcf".format(len(d)))
    for k in d.keys():
        if positions.count(k) > 1:
            del d[k]
    print("{0} positions after removing postions with multiple variants in VCF".format(len(d)))
    return positions, d

def recode_tped(d):
    for root, dirs, files in os.walk(args.tpedDir):
        for popFile in files:
            pop = popFile.split("_")[0]
            with open(os.path.join(root, popFile), 'r') as infile, open(pop + '_recoded.tped', 'w') as outfile:
                for line in infile:
                    line = line.strip().split()
                    pos = int(line[3]) 
                    if pos in d:
                        GT = line[4:]
                        #alleles = set(line[4:])
                        tempGT = "".join(GT)
                        newGT = tempGT.replace(d[pos][0], "0")
                        newGT = newGT.replace(d[pos][1], "1")
                        outfile.write("\t".join(line[0:4]) + "\t" + "\t".join(newGT) + '\n') 


args = get_arguments()
positions, d = find_ancestral()
recode_tped(d)
